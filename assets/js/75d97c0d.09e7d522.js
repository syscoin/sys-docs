"use strict";(self.webpackChunksys_docs=self.webpackChunksys_docs||[]).push([[1174],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(n),h=s,f=p["".concat(l,".").concat(h)]||p[h]||u[h]||o;return n?a.createElement(f,r(r({ref:t},d),{},{components:n})):a.createElement(f,r({ref:t},d))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2804:(e,t,n)=>{n.r(t),n.d(t,{default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>i});var a=n(87462),s=(n(67294),n(3905));const o={},r={unversionedId:"dev-resources/sys/asset-index",id:"dev-resources/sys/asset-index",isDocsHomePage:!1,title:"SPT Asset Index Technical Description",description:"Introduction",source:"@site/docs/dev-resources/sys/asset-index.mdx",sourceDirName:"dev-resources/sys",slug:"/dev-resources/sys/asset-index",permalink:"/docs/dev-resources/sys/asset-index",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Rollups",permalink:"/docs/dev-resources/nevm/zk-rollups"},next:{title:"SPT Exchange Integration",permalink:"/docs/dev-resources/sys/exchange-integration"}},i=[],l={toc:i};function c(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Introduction")),(0,s.kt)("p",null,"Asset index is a high performance blockchain re-organization aware flag that allows users to be able to query historical information related to Syscoin Assets."),(0,s.kt)("p",null,"The asset index was created as a way for exchanges and other services to be able to manage Syscoin assets via viewing transactional history without requiring third party tools. This index is useful for viewing information only. The current set of RPCs to create transactions for managing assets are created in a way that are not dependent on a wallet and thus are compatible with signing tools such as hardware wallets. This is a reference implementation and of course third party tools in some contexts make sense. However as a fallback we created a reference implementation for those requiring all information to be available from within Syscoin Core itself without the need for custom modifications. You do not need to enable txindex and it is pruning compatible. There are two RPCs exposed for the use of asset index."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"listassetindex - This will let you filter all assets + asset allocations via an asset GUID and/or an address. You can leave the address field empty to scan through the entire asset."),(0,s.kt)("li",{parentName:"ol"},"listassetindexassets - Takes in an address and returns any asset GUIDs that are owned by the address as allocations.")),(0,s.kt)("p",null,"There are two configuration variables to use when dealing with an asset index. -assetindex and -blockindex. Blockindex allows once to view the block related to an asset transaction. It is re-org aware. This means that every transaction is associated with a blockhash and on a disconnect of a block the blockindex is updated to remove the blockhash associated with the disconnected transactions in the block(s) rolled back. The blockhash is output in the ",(0,s.kt)("inlineCode",{parentName:"p"},"listassetindex")," command as the block_hash field. This makes the assetindex re-org aware by extension as one would be able to rely on the block_hash field of the returned entries to know if a transaction was confirmed or potentially not part of the longest chain on a node."),(0,s.kt)("p",null,"You somtimes do not want to have to index all assets in Syscoin and just want to index the ones you care about and thus there are configurations for those cases you can read about below."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Use Cases")),(0,s.kt)("p",null,"The main usecases of using such an index are as follows:"),(0,s.kt)("p",null,"Use case #1: enter an asset GUID and address and get back a list of transactions (sends/receives) related to that asset/address tuple."),(0,s.kt)("p",null,"Use case #2: enter an address and view all assets connected to an address."),(0,s.kt)("p",null,"Use case #3: enter an asset GUID and view all transactions (sends/receives/updates) related to an asset."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Motivation")),(0,s.kt)("p",null,"We needed high performance to avoid large delays as transactional volume increased. The requirement for this index in the design phase was to have O(1) time complexity and <= O(N) space complexity. We solved this by using a Key-Value storage database and using a tuple of information as Key to reduce lookup complexity yet remain flexible to be able to walk through the historical information with intuition. We require the Key to have a page number to create this efficiency and thus consuming clients would work under a paged view mechanism. The default page size is 25 results per page."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text"},"// Configuration Parameters (in syscoin.conf or passed into the binary when running Syscoin Core):\n\nAssetindex - true if we want to index asset history, false to skip. Default is false. Set to true if consuming client is a block explorer, asset wallet, crypto-currency exchange or any other client that needs history of assets.\n\nAssetindexguids - comma seperated list of asset guids to index, empty for all if Assetindex is true.\n\nAssetindexpagesize - if Assetindex is true set this to a page size based on how the consuming client will render results. Default is 10.\n\nBlockindex - true if you want block_hash information for every asset transaction result from listassetindex RPC\n")),(0,s.kt)("p",null,"Note that ",(0,s.kt)("inlineCode",{parentName:"p"},"Assetindexpagesize")," is dynamic and set upon configuration, if changed you need to reindex the blockchain from start."),(0,s.kt)("p",null,"Database Structure:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cplusplus"},"Collection for TXIDs for each allocation, Get/Set - <asset guid><address><page number> = vector<txid> (size of vector is based on page size);\n\nCurrent highest page number, Get/Set - <page number> = int;\n\nCollection for JSON outputs for TXID, Get/Set - <txid> = JSON output of transaction;\n\nAssets per address, Get/Set - <address> = vector<asset guid>;\n\nTXIDs of asset update/send/receive, Get/Set - <asset guid> = vector<txid>;\n// In Memory structure:\nGet/Set - Set of TXID\u2019s (lets call it confirmedTXIDs);\n")),(0,s.kt)("p",null,"Pseudocode for Connect Block logic:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cplusplus"},"Set TXID to confirmedTXIDs;\n\nGet page number as pageNum;\n\nGet vector<txid> based on <asset guid><address><pageNum>;\n\nIf vector size if >= 10 increase pageNum and create new vector;\n\nSet JSON output of transaction to vector<txid> collection of JSON outputs per TXID;\n\nSet vector<txid> based on <asset guid><address><pageNum> to TXID collection for asset allocation;\n\nSet pageNum to highest page number collection;\n")),(0,s.kt)("p",null,"Pseudocode for Disconnect Block logic:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cplusplus"},"For every transaction:\n        Remove TXID from confirmedTXIDs;\n")),(0,s.kt)("p",null,"Pseudocode for listassetindex RPC function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text"},"/*Scan an asset/address tuple for a page of transaction. Consuming clients should page results based on page size set in configuration to the core. Will return all tx\u2019s regardless if they were re-orged or not. A confirmed parameter will indicate if the transaction is part of the blockchain and confirmed.\n    Parameters:\n        Asset guid - asset guid number specific to each asset\n        Address - a sender or receiver address that owns an asset. If empty then assume  you want all tx\u2019s based on asset.\n        Page number - return specific page number of transactions. 0 by default*/\n    \nIf Address is empty:\n    Get vector<txid> based on <asset guid><page number>;\nElse:\n    Get vector<txid> based on <asset guid><address><page number>;\n\nFor each txid in vector:\n    Get JSON output based on txid;\n    Get blockhash of txid from blockindex (if exist otherwise set to empty);\n    Add blockhash of txid to JSON output as block_hash;\n\nReturn JSON output to caller\n")),(0,s.kt)("p",null,"Pseudocode for listassetindexassets RPC function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cplusplus"},"/*Assets per Address:\nReturns all asset guids related to an address at any time in blockchain history.\n    Parameters:\n        Address - a sender or receiver address that potentially owns an asset*/\n\nGet vector<asset guid> based on <address>;\n\nReturn JSON of all assets found to caller;\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q&A")),(0,s.kt)("p",null,"What does re-org protected mean?\nIt means that if the blockchain tip is disconnected for whatever reason (longer chain is found) then you have to rollback transactions, we wouldn't want our asset view to incorrectly show transactions as confirmed when they have been rolled back."),(0,s.kt)("p",null,"What does asset indexing mean?\nIt means that we need a way to show all transactions related to an asset+address tuple. You need to be able to as a wallet or explorer view pertaining transactions for your asset allocation as a sender or receiver."))}c.isMDXComponent=!0}}]);